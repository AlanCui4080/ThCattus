// Copyright 2025 AlanCui4080
//
// Licensed under the Apache License, Version 2.0 (the "License"): you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

// 
// therm_v1_processor_vlg_tst.vt:
// testbench for therm_v1_processor
//


// CAUTION: PRACTICAL CONTENT GENERATED BY AI, CONFIRM BY HUMAN BEFORE USE

`timescale 1 ps/ 1 ps
module therm_v1_processor_vlg_tst();

// Memory parameters
parameter MEM_SIZE = 1024; // 1K words
parameter ADDR_WIDTH = 32;
parameter DATA_WIDTH = 32;

// Memory arrays
reg [DATA_WIDTH-1:0] inst_memory [0:MEM_SIZE-1];
reg [DATA_WIDTH-1:0] data_memory [0:MEM_SIZE-1];

// Existing registers
reg [31:0] databus_hrdata;
reg databus_hready;
reg [1:0] databus_hresp;
reg [31:0] instbus_hrdata;
reg instbus_hready;
reg [1:0] instbus_hresp;
reg processor_clk;
reg processor_resetn = 0;

// Existing wires (unchanged)
wire [31:0]  databus_haddr;
wire [2:0]  databus_hbrust;
wire databus_hclk;
wire [3:0]  databus_hprot;
wire databus_hresetn;
wire [2:0]  databus_hsize;
wire [1:0]  databus_htrans;
wire [31:0]  databus_hwdata;
wire databus_hwrite;
wire [31:0]  instbus_haddr;
wire [2:0]  instbus_hbrust;
wire instbus_hclk;
wire [3:0]  instbus_hprot;
wire instbus_hresetn;
wire [2:0]  instbus_hsize;
wire [1:0]  instbus_htrans;
wire [31:0]  instbus_hwdata;
wire instbus_hwrite;

// Clock generation
initial begin
    processor_clk = 0;
    forever #10 processor_clk = ~processor_clk;
end

// Reset generation
initial begin
    processor_resetn = 0;
    #100 processor_resetn = 1;
end

// Instruction memory response
always @(posedge processor_clk) begin
    if (!processor_resetn) begin
        instbus_hrdata <= 32'h0;
        instbus_hready <= 1'b1;
        instbus_hresp <= 2'b00;
    end else begin
        instbus_hready <= 1'b1;
        instbus_hresp <= 2'b00;
        if (instbus_htrans[1]) begin // NONSEQ or SEQ transfer
            instbus_hrdata <= inst_memory[instbus_haddr[11:2]]; // Word aligned address
        end
    end
end

// Data memory response
always @(posedge processor_clk) begin
    if (!processor_resetn) begin
        databus_hrdata <= 32'h0;
        databus_hready <= 1'b1;
        databus_hresp <= 2'b00;
    end else begin
        databus_hready <= 1'b1;
        databus_hresp <= 2'b00;
        if (databus_htrans[1]) begin // NONSEQ or SEQ transfer
            if (databus_hwrite) begin
                data_memory[databus_haddr[11:2]] <= databus_hwdata;
            end else begin
                databus_hrdata <= data_memory[databus_haddr[11:2]];
            end
        end
    end
end

integer i;
// Initialize memories and define test program
initial begin
    // Initialize all memory locations to zero first
    for (i = 0; i < MEM_SIZE; i=i+1) begin
        inst_memory[i] = 32'h0;
        data_memory[i] = 32'h0;
    end
    // Test program with larger numbers
    inst_memory[0] = 32'h0FF00093;  // addi x1, x0, 255   # x1 = 255
    inst_memory[1] = 32'h12800113;  // addi x2, x0, 296   # x2 = 296
    inst_memory[2] = 32'hF0000193;  // addi x3, x0, -256  # x3 = -256
    inst_memory[3] = 32'h00200593;  // addi x11, x0, 2    # x11 = 2

    // Arithmetic instructions
    inst_memory[4] = 32'h002081B3;  // add  x3, x1, x2   # x3 = 551
    inst_memory[5] = 32'h40208233;  // sub  x4, x1, x2   # x4 = -41
    inst_memory[6] = 32'h0020F2B3;  // and  x5, x1, x2   # x5 = 40
    inst_memory[7] = 32'h0020E333;  // or   x6, x1, x2   # x6 = 511
    inst_memory[8] = 32'h0020C3B3;  // xor  x7, x1, x2   # x7 = 471
    inst_memory[9] = 32'h00B09433;  // sll  x8, x1, x11   # x8 = shift left by 2
    inst_memory[10] = 32'h00B0D4B3; // srl  x9, x1, x11   # x9 = shift right by 2
    inst_memory[11] = 32'h40B0D533; // sra  x10, x1, x11  # x10 = arith shift by 2

    // Store results
    inst_memory[12] = 32'h00302023; // sw x3, 0(x0)
    inst_memory[13] = 32'h00402223; // sw x4, 4(x0)
    inst_memory[14] = 32'h00502423; // sw x5, 8(x0)
    inst_memory[15] = 32'h00602623; // sw x6, 12(x0)
    inst_memory[16] = 32'h00702823; // sw x7, 16(x0)
    inst_memory[17] = 32'h00802A23; // sw x8, 20(x0)
    inst_memory[18] = 32'h00902C23; // sw x9, 24(x0)
    inst_memory[19] = 32'h00A02E23; // sw x10, 28(x0)
    inst_memory[20] = 32'h0000006F; // Infinite loop
end

// Monitor results
initial begin
    $display("Starting instruction execution monitoring...");
    #10000;
    if (data_memory[0] !== 32'hx)
        $display("%s Time=%0t ADD: data_mem[0]=%h (Expected: 551)", 
                (data_memory[0] === 32'h227 ? "PASS" : "FAIL"), $time, data_memory[0]);
    if (data_memory[1] !== 32'hx)
        $display("%s Time=%0t SUB: data_mem[1]=%h (Expected: -41)", 
                (data_memory[1] === 32'hFFFFFFD7 ? "PASS" : "FAIL"), $time, data_memory[1]);
    if (data_memory[2] !== 32'hx)
        $display("%s Time=%0t AND: data_mem[2]=%h (Expected: 40)", 
                (data_memory[2] === 32'h28 ? "PASS" : "FAIL"), $time, data_memory[2]);
    if (data_memory[3] !== 32'hx)
        $display("%s Time=%0t OR:  data_mem[3]=%h (Expected: 511)", 
                (data_memory[3] === 32'h1FF ? "PASS" : "FAIL"), $time, data_memory[3]);
    if (data_memory[4] !== 32'hx)
        $display("%s Time=%0t XOR: data_mem[4]=%h (Expected: 471)", 
                (data_memory[4] === 32'h1D7 ? "PASS" : "FAIL"), $time, data_memory[4]);
    if (data_memory[5] !== 32'hx)
        $display("%s Time=%0t SLL: data_mem[5]=%h (Expected: 1020)", 
                (data_memory[5] === 32'h3FC ? "PASS" : "FAIL"), $time, data_memory[5]);
    if (data_memory[6] !== 32'hx)
        $display("%s Time=%0t SRL: data_mem[6]=%h (Expected: 63)", 
                (data_memory[6] === 32'h3F ? "PASS" : "FAIL"), $time, data_memory[6]);
    if (data_memory[7] !== 32'hx)
        $display("%s Time=%0t SRA: data_mem[7]=%h (Expected: 63)", 
                (data_memory[7] === 32'h3F ? "PASS" : "FAIL"), $time, data_memory[7]);
    $stop();
end

// Processor instance
therm_v1_processor i1 (
    // Port connections remain unchanged
    .databus_haddr(databus_haddr),
    .databus_hbrust(databus_hbrust),
    .databus_hclk(databus_hclk),
    .databus_hprot(databus_hprot),
    .databus_hrdata(databus_hrdata),
    .databus_hready(databus_hready),
    .databus_hresetn(databus_hresetn),
    .databus_hresp(databus_hresp),
    .databus_hsize(databus_hsize),
    .databus_htrans(databus_htrans),
    .databus_hwdata(databus_hwdata),
    .databus_hwrite(databus_hwrite),
    .instbus_haddr(instbus_haddr),
    .instbus_hbrust(instbus_hbrust),
    .instbus_hclk(instbus_hclk),
    .instbus_hprot(instbus_hprot),
    .instbus_hrdata(instbus_hrdata),
    .instbus_hready(instbus_hready),
    .instbus_hresetn(instbus_hresetn),
    .instbus_hresp(instbus_hresp),
    .instbus_hsize(instbus_hsize),
    .instbus_htrans(instbus_htrans),
    .instbus_hwdata(instbus_hwdata),
    .instbus_hwrite(instbus_hwrite),
    .processor_clk(processor_clk),
    .processor_resetn(processor_resetn)
);

endmodule
